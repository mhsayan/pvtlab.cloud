---
import IconSearch from "@/assets/icons/IconSearch.svg";
---

<div
  id="search-modal"
  class="search-modal"
  role="dialog"
  aria-modal="true"
  aria-labelledby="search-modal-title"
  aria-hidden="true"
>
  <div class="search-backdrop" data-search-close></div>
  <div class="search-container">
    <div class="search-card">
      <!-- Search Input -->
      <div class="search-input-wrapper">
        <IconSearch class="search-input-icon" />
        <input
          id="search-input"
          type="text"
          placeholder="Search posts..."
          class="search-input"
          autocomplete="off"
          aria-label="Search posts"
        />
        <div class="search-shortcut">
          <kbd class="search-kbd"><span class="search-kbd-modifier"></span>K</kbd>
        </div>
      </div>

      <!-- Search Results -->
      <div id="search-results" class="search-results">
        <!-- Empty State -->
        <div id="search-empty" class="search-empty">
          <p class="search-empty-text">Start typing to search posts</p>
        </div>

        <!-- Loading State -->
        <div id="search-loading" class="search-loading hidden">
          <div class="search-spinner"></div>
          <p>Searching...</p>
        </div>

        <!-- Results List -->
        <ul
          id="search-results-list"
          class="search-results-list hidden"
          role="listbox"
          aria-label="Search results"
        >
        </ul>

        <!-- No Results -->
        <div id="search-no-results" class="search-no-results hidden">
          <p>No posts found for your search.</p>
        </div>

        <!-- Dev Warning -->
        <div id="search-dev-warning" class="search-dev-warning hidden">
          <p><strong>Dev mode:</strong> Run <code>pnpm run build</code> first to index content.</p>
        </div>
      </div>

      <!-- Footer -->
      <div class="search-footer">
        <div class="search-footer-hints">
          <span><kbd>↑↓</kbd> Navigate</span>
          <span><kbd>↵</kbd> Select</span>
          <span><kbd>esc</kbd> Close</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  interface SearchResult {
    url: string;
    meta: {
      title?: string;
    };
    excerpt?: string;
  }

  interface PagefindFragment {
    url: string;
    meta: {
      title?: string;
    };
    excerpt: string;
  }

  interface PagefindSearchResult {
    id: string;
    score: number;
    data: () => Promise<PagefindFragment>;
  }

  interface PagefindResponse {
    results: PagefindSearchResult[];
  }

  interface Pagefind {
    search: (query: string) => Promise<PagefindResponse>;
  }

  function initSearchModal() {
    const modal = document.getElementById("search-modal") as HTMLElement | null;
    const searchInput = document.getElementById("search-input") as HTMLInputElement | null;
    const searchResultsList = document.getElementById("search-results-list") as HTMLUListElement | null;
    const searchEmpty = document.getElementById("search-empty");
    const searchLoading = document.getElementById("search-loading");
    const searchNoResults = document.getElementById("search-no-results");
    const searchDevWarning = document.getElementById("search-dev-warning");
    const kbdModifier = document.querySelector(".search-kbd-modifier");

    if (!modal || !searchInput || !searchResultsList) return;

    // Capture non-null references for use in closures
    const modalEl = modal;
    const inputEl = searchInput;
    const resultsEl = searchResultsList;

    // Set keyboard modifier based on OS
    const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.userAgent);
    if (kbdModifier) {
      kbdModifier.textContent = isMac ? "⌘" : "Ctrl+";
    }

    let pagefind: Pagefind | null = null;
    let pagefindLoading: Promise<Pagefind | null> | null = null;
    let selectedIndex = -1;
    let searchTimeout: ReturnType<typeof setTimeout>;
    let lastFocusedElement: HTMLElement | null = null;

    // Helper to show/hide elements
    function showElement(el: HTMLElement | null) {
      if (el) el.classList.remove("hidden");
    }
    function hideElement(el: HTMLElement | null) {
      if (el) el.classList.add("hidden");
    }

    // Load Pagefind dynamically (using Function to avoid Vite analyzing the import)
    async function loadPagefind(): Promise<Pagefind | null> {
      if (pagefind) return pagefind;
      if (pagefindLoading) return pagefindLoading;

      pagefindLoading = (async () => {
        try {
          // Use Function constructor to create dynamic import that Vite won't analyze
          const importFn = new Function("return import('/pagefind/pagefind.js')");
          const module = await importFn();

          // Pagefind exports search function directly on the module
          if (module && typeof module.search === "function") {
            pagefind = module as Pagefind;
            return pagefind;
          }

          // Fallback: check if it's on default export
          if (module?.default && typeof module.default.search === "function") {
            pagefind = module.default as Pagefind;
            return pagefind;
          }

          throw new Error("Pagefind search function not found");
        } catch (e) {
          // Show dev warning if in dev mode
          if (import.meta.env.DEV) {
            showElement(searchDevWarning);
            hideElement(searchEmpty);
          }
          return null;
        }
      })();

      return pagefindLoading;
    }

    // Open modal
    function openModal() {
      lastFocusedElement = document.activeElement as HTMLElement;
      modalEl.classList.add("open");
      modalEl.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";

      // Focus input after animation
      setTimeout(() => {
        inputEl.focus();
      }, 50);
    }

    // Close modal
    function closeModal() {
      modalEl.classList.remove("open");
      modalEl.setAttribute("aria-hidden", "true");
      document.body.style.overflow = "";
      inputEl.value = "";
      resetResults();

      // Restore focus
      if (lastFocusedElement) {
        lastFocusedElement.focus();
      }
    }

    // Reset results to empty state
    function resetResults() {
      selectedIndex = -1;
      hideElement(resultsEl);
      hideElement(searchNoResults);
      hideElement(searchLoading);
      if (!import.meta.env.DEV || pagefind) {
        hideElement(searchDevWarning);
        showElement(searchEmpty);
      }
      resultsEl.innerHTML = "";
    }

    // Perform search
    async function performSearch(query: string) {
      if (!query.trim()) {
        resetResults();
        return;
      }

      const pf = await loadPagefind();
      if (!pf) {
        hideElement(searchLoading);
        showElement(searchNoResults);
        return;
      }

      // Show loading
      hideElement(searchEmpty);
      hideElement(resultsEl);
      hideElement(searchNoResults);
      hideElement(searchDevWarning);
      showElement(searchLoading);

      try {
        const searchResponse = await pf.search(query);

        if (!searchResponse || !searchResponse.results) {
          hideElement(searchLoading);
          showElement(searchNoResults);
          return;
        }

        const results: SearchResult[] = [];

        // Load first 8 results
        for (const result of searchResponse.results.slice(0, 8)) {
          const data = await result.data();
          results.push({
            url: data.url,
            meta: data.meta,
            excerpt: data.excerpt,
          });
        }

        hideElement(searchLoading);

        if (results.length === 0) {
          showElement(searchNoResults);
          return;
        }

        // Render results
        renderResults(results);
      } catch (err) {
        hideElement(searchLoading);
        showElement(searchNoResults);
      }
    }

    // Render results
    function renderResults(results: SearchResult[]) {
      resultsEl.innerHTML = results
        .map(
          (result, index) => `
          <li
            role="option"
            aria-selected="${index === selectedIndex}"
            class="search-result-item"
            data-index="${index}"
          >
            <a href="${result.url}" class="search-result-link">
              <span class="search-result-title">${result.meta.title || "Untitled"}</span>
              ${result.excerpt ? `<span class="search-result-excerpt">${result.excerpt}</span>` : ""}
            </a>
          </li>
        `
        )
        .join("");

      showElement(resultsEl);
      selectedIndex = -1;
    }

    // Update selection highlight
    function updateSelection() {
      const items = resultsEl.querySelectorAll(".search-result-item");
      items.forEach((item, index) => {
        if (index === selectedIndex) {
          item.classList.add("selected");
          item.setAttribute("aria-selected", "true");
          item.scrollIntoView({ block: "nearest" });
        } else {
          item.classList.remove("selected");
          item.setAttribute("aria-selected", "false");
        }
      });
    }

    // Navigate to selected result
    function navigateToSelected() {
      const items = resultsEl.querySelectorAll(".search-result-item");
      if (selectedIndex >= 0 && selectedIndex < items.length) {
        const link = items[selectedIndex].querySelector("a") as HTMLAnchorElement;
        if (link) {
          closeModal();
          window.location.href = link.href;
        }
      }
    }

    // Event listeners
    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      // Open with Cmd/Ctrl + K
      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault();
        if (modalEl.classList.contains("open")) {
          closeModal();
        } else {
          openModal();
        }
      }

      // Close with Escape
      if (e.key === "Escape" && modalEl.classList.contains("open")) {
        e.preventDefault();
        closeModal();
      }
    });

    // Search input
    inputEl.addEventListener("input", () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        performSearch(inputEl.value);
      }, 200);
    });

    // Keyboard navigation in results
    inputEl.addEventListener("keydown", (e) => {
      const items = resultsEl.querySelectorAll(".search-result-item");
      if (items.length === 0) return;

      if (e.key === "ArrowDown") {
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
        updateSelection();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, -1);
        updateSelection();
      } else if (e.key === "Enter" && selectedIndex >= 0) {
        e.preventDefault();
        navigateToSelected();
      }
    });

    // Click on backdrop to close
    modalEl.querySelectorAll("[data-search-close]").forEach((el) => {
      el.addEventListener("click", closeModal);
    });

    // Click on results
    resultsEl.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      const item = target.closest(".search-result-item");
      if (item) {
        const link = item.querySelector("a") as HTMLAnchorElement;
        if (link) {
          closeModal();
        }
      }
    });

    // Expose open function for header button
    (window as { openSearchModal?: () => void }).openSearchModal = openModal;
  }

  // Initialize on page load
  initSearchModal();

  // Re-initialize on Astro page transitions
  document.addEventListener("astro:after-swap", initSearchModal);
</script>
